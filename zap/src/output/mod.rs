use std::fmt::Display;

use crate::{irgen::Stmt, parser::Ty, util::NumTy};

pub mod client;
pub mod server;

pub trait Output {
	fn push(&mut self, s: &str);
	fn indent(&mut self);
	fn dedent(&mut self);
	fn push_indent(&mut self);

	fn push_line(&mut self, s: &str) {
		self.push_indent();
		self.push(s);
		self.push("\n");
	}

	fn push_stmt(&mut self, stmt: &Stmt) {
		if matches!(stmt, Stmt::ElseIf(..) | Stmt::Else | Stmt::End) {
			self.dedent();
		}

		match &stmt {
			Stmt::Local(name, expr) => {
				if let Some(expr) = expr {
					self.push_line(&format!("local {name} = {expr}"));
				} else {
					self.push_line(&format!("local {name}"));
				}
			}

			Stmt::Assign(var, expr) => self.push_line(&format!("{var} = {expr}")),
			Stmt::Error(msg) => self.push_line(&format!("error({msg})")),
			Stmt::Assert(cond, msg) => match msg {
				Some(msg) => self.push_line(&format!("assert({cond}, {msg})")),
				None => self.push_line(&format!("assert({cond})")),
			},

			Stmt::Call(var, method, args) => match method {
				Some(method) => self.push_line(&format!(
					"{var}:{method}({})",
					args.iter().map(|arg| arg.to_string()).collect::<Vec<_>>().join(", ")
				)),

				None => self.push_line(&format!(
					"{var}({})",
					args.iter().map(|arg| arg.to_string()).collect::<Vec<_>>().join(", ")
				)),
			},

			Stmt::NumFor { var, from, to } => self.push_line(&format!("for {var} = {from}, {to} do")),
			Stmt::GenFor { key, val, obj } => self.push_line(&format!("for {key}, {val} in {obj} do")),
			Stmt::If(cond) => self.push_line(&format!("if {cond} then")),
			Stmt::ElseIf(cond) => self.push_line(&format!("elseif {cond} then")),
			Stmt::Else => self.push_line("else"),

			Stmt::End => self.push_line("end"),
		};

		if matches!(
			stmt,
			Stmt::NumFor { .. } | Stmt::GenFor { .. } | Stmt::If(..) | Stmt::ElseIf(..) | Stmt::Else
		) {
			self.indent();
		};
	}

	fn push_stmts(&mut self, stmts: &[Stmt]) {
		for stmt in stmts {
			self.push_stmt(stmt);
		}
	}

	fn push_ty(&mut self, ty: &Ty) {
		match ty {
			Ty::Bool => self.push("boolean"),

			Ty::F32(_) => self.push("number"),
			Ty::F64(_) => self.push("number"),

			Ty::U8(_) => self.push("number"),
			Ty::U16(_) => self.push("number"),
			Ty::U32(_) => self.push("number"),

			Ty::I8(_) => self.push("number"),
			Ty::I16(_) => self.push("number"),
			Ty::I32(_) => self.push("number"),

			Ty::Str { .. } => self.push("string"),

			Ty::Arr { ty, .. } => {
				self.push("{ ");
				self.push_ty(ty);
				self.push(" }");
			}

			Ty::Map { key, val } => {
				self.push("{ [");
				self.push_ty(key);
				self.push("]: ");
				self.push_ty(val);
				self.push(" }");
			}

			Ty::Struct { fields } => {
				self.push("{\n");
				self.indent();

				for (name, ty) in fields.iter() {
					self.push_indent();
					self.push(&format!("{name}: "));
					self.push_ty(ty);
					self.push(",\n");
				}

				self.dedent();
				self.push_indent();
				self.push("}");
			}

			Ty::Enum { variants } => self.push(
				&variants
					.iter()
					.map(|v| format!("\"{}\"", v))
					.collect::<Vec<_>>()
					.join(" | ")
					.to_string(),
			),

			Ty::Instance(strict, name) => {
				self.push(if let Some(name) = name { name } else { "Instance" });

				if *strict {
					self.push("?")
				}
			}
			Ty::Vector3 => self.push("Vector3"),

			Ty::Ref(name) => self.push(&name.to_string()),

			Ty::Optional(ty) => {
				self.push_ty(ty);
				self.push("?");
			}
		}
	}

	fn push_file_header(&mut self) {
		self.push_line("--!native");
		self.push_line("--!optimize 2");

		self.push_line(&format!(
			"-- Generated by Zap v{} (https://github.com/red-blox/zap)",
			env!("CARGO_PKG_VERSION")
		));

		self.push(include_str!("base.luau"));
	}
}

impl Display for NumTy {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			NumTy::F32 => write!(f, "f32"),
			NumTy::F64 => write!(f, "f64"),

			NumTy::U8 => write!(f, "u8"),
			NumTy::U16 => write!(f, "u16"),
			NumTy::U32 => write!(f, "u32"),

			NumTy::I8 => write!(f, "i8"),
			NumTy::I16 => write!(f, "i16"),
			NumTy::I32 => write!(f, "i32"),
		}
	}
}
